#!/bin/sh
#
# Copyright (c) 2012 Ericsson AB.
# All rights reserved.
#
# The information in this document is the property of Ericsson.
# Except as specifically authorized in writing by Ericsson, the
# receiver of this document shall keep the information contained
# herein confidential and shall protect the same in whole or in
# part from disclosure and dissemination to third parties.
# Disclosure and dissemination to the receiver's employees shall
# only be made on a strict need to know basis.
#
#
# Function:     comea-authentication-method-set <authentication-type>..
# Availability: control nodes
#
# <authentication-type> is set to either 'default' or 'ldap', and in the
# latter case the <--sub-arg=value>:s are used to specify ldap details.
#
# 'ldap' sets the variables to make COM use LDAP for authentication and authorization of users.
# 'default' will reset the authentication settings to the default.
# This is described in the document COM EA SPI Programmer's Guide
#
# Return values:
#   0  - if everything is ok.
#   ERROR - if something fails.
#

# Script debug
#set -x

DEFAULT_UMASK=`umask`
NOHOME=${COMEA_ROOT_DIR}/home/nohome
PREPARE=0

# Auto-generation message
AUTO_MSG="# Entries below auto-generated by 'comea-authentication-method-set'"

# Directory variables. (For COM testing: Don't change these two env variable names)
ETC_DIR="/etc"
CLUSTER_ETC_DIR="/cluster/etc"
DO_SYSLOG=0

# Workaround for bug in CMW start of com. Sets wrong value in $HOME
# TODO: CMW TR # xxxx ? Create a COM TR for same problem
# This line should be deleted when fixed in OpenSAF
MYUSER="`id -u -n`"
HOME="`grep ${MYUSER} /etc/passwd | cut -d ":" -f6 `"
# End workaround 

# Create necessary test directories on cluster for syncd.
if [ ! -d $CLUSTER_ETC_DIR/openldap ]; then
   mkdir -p $CLUSTER_ETC_DIR/openldap
fi
if [ ! -d $CLUSTER_ETC_DIR/pam.d ]; then
   mkdir -p $CLUSTER_ETC_DIR/pam.d
fi

readonly ERROR=1
ADD_NEWLINE=0

# Old LOTC script path
OLD_AUTH_CMD=${COMEA_ROOT_DIR}/usr/lib/cmwea/authentication-method-set

OPENLDAP_DIR="$ETC_DIR/openldap"
OPENLDAP_GENFILE_DIR="$ETC_DIR/openldap"
CLUSTER_OPENLDAP_DIR="$CLUSTER_ETC_DIR/openldap"

PAM_DIR="$ETC_DIR/pam.d"
PAM_GENFILE_DIR="$ETC_DIR/pam.d"
CLUSTER_PAM_DIR="$CLUSTER_ETC_DIR/pam.d"

ETC_GENFILE_DIR="$ETC_DIR"

HOME_DIR="$HOME"
HOME_GENFILE_DIR="$HOME_DIR"

# File variables
OPENLDAP_CONF="$OPENLDAP_DIR/ldap.conf"
OPENLDAP_CONF_DEFAULT="$OPENLDAP_GENFILE_DIR/.ldap.conf.default"
OPENLDAP_CONF_TMP="$OPENLDAP_GENFILE_DIR/.ldap.conf.tmp"
CLUSTER_OPENLDAP_CONF="$CLUSTER_OPENLDAP_DIR/ldap.conf"

OPENLDAP_LDAPRC="$HOME_DIR/.ldaprc"
OPENLDAP_LDAPRC_DEFAULT="$HOME_GENFILE_DIR/.ldaprc.default"
OPENLDAP_LDAPRC_TMP="$HOME_GENFILE_DIR/.ldaprc.tmp"
CLUSTER_OPENLDAP_LDAPRC="$CLUSTER_OPENLDAP_DIR/.ldaprc"

LDAP_CONF="$ETC_DIR/ldap.conf"
LDAP_CONF_DEFAULT="$ETC_GENFILE_DIR/.ldap.conf.default"
LDAP_CONF_TMP="$ETC_GENFILE_DIR/.ldap.conf.tmp"
CLUSTER_LDAP_CONF="$CLUSTER_ETC_DIR/ldap.conf"

LDAP_SECRET="$ETC_DIR/ldap.secret"
LDAP_SECRET_DEFAULT="$ETC_GENFILE_DIR/.ldap.secret.default"
LDAP_SECRET_TMP="$ETC_GENFILE_DIR/.ldap.secret.tmp"
CLUSTER_LDAP_SECRET="$CLUSTER_ETC_DIR/ldap.secret"

NSSWITCH_CONF="$ETC_DIR/nsswitch.conf"
NSSWITCH_CONF_DEFAULT="$ETC_GENFILE_DIR/.nsswitch.conf.default"
NSSWITCH_CONF_TMP="$ETC_GENFILE_DIR/.nsswitch.conf.tmp"
CLUSTER_NSSWITCH_CONF="$CLUSTER_ETC_DIR/nsswitch.conf"

PAM_SSHD_CONF="$PAM_DIR/sshd"
PAM_SSHD_CONF_DEFAULT="$PAM_GENFILE_DIR/.sshd.default"
PAM_SSHD_CONF_TMP="$PAM_GENFILE_DIR/.sshd.tmp"
CLUSTER_PAM_SSHD_CONF="$CLUSTER_PAM_DIR/sshd"

SYNCD_CONF="$ETC_DIR/syncd.conf"
#SYNCD_CONF_DEFAULT="$ETC_DIR/.syncd.conf.default"

#Path to the file which contains LOTC Version installed on the node.
LOTC_VERSION="$ETC_DIR/cluster/product/version"

# Argument variables
TLS_CIPHERS="ALL:!aNULL:!eNULL:!DES:@STRENGTH"

# Will be set if TLS should be started
#ACTIVATE_TLS=

# Ignore re-setting default during boot
#IGNORE_SET_DEFAULT=

# If the group com-ldap is defined in /etc/group, the GID will override the 
# GID returned by the LDAP server
LDAP_GID=`grep ^com-ldap ${COMEA_ROOT_DIR}/etc/group | awk -F':' '{print $3}'`

#To check the mandatory attibute baseDn is given or not
baseDnUsed=false

#Method for Logging Errors to the Syslog.
error() {
    echo "ER $*" >&2
    logger -t "`basename $0`[$$]" -p local0.err "$*"
    exit_now $ERROR
}

#Method for Logging Warnings to the Syslog.
error_noexit() {
    echo "WA $*" >&2
    logger -t "`basename $0`[$$]" -p local0.err "$*"
}


syslog_message() {
    if [ $DO_SYSLOG -eq 1 ]; then
	logger -p local0.debug -t "`basename $0`[$$]" "$*"
    fi
}

exit_now() {
    if [ $DO_SYSLOG -eq 1 ]; then
	logger -p local0.debug -t "`basename $0`[$$]: File $COMEA_ROOT_DIR/test_log/authentication-method-set_prepare.log" -f $COMEA_ROOT_DIR/test_log/authentication-method-set_prepare.log 2> /dev/null
	logger -p local0.debug -t "`basename $0`[$$]: File $COMEA_ROOT_DIR/test_log/authentication-method-set_fail.log" -f $COMEA_ROOT_DIR/test_log/authentication-method-set_fail.log 2> /dev/null
    fi
    exit $1
}

# This function adds the pam filter based on the node type(s).
# It fill add a part to the filter, e.g, (ericssonUserAuthenticationScope=nodeType01.location1) 
# for each node type.Each node type is separated by the delimiter ":".
format_pam_filter() {
    syslog_message "Enter format_pam_filter()"

    objectClass_l="(objectClass=posixAccount)"
    nodetype_l="$1"
     size_l=0
    nodetypelist_l=`echo "$nodetype_l" | sed 's/:/\ /g'`
    for nt in $nodetypelist_l; do
        pam_filter=$pam_filter`echo "(ericssonUserAuthenticationScope="${nt}")"`
        size_l=`expr $size_l + 1`
    done

    # If more than one filter is specified, they will be OR:ed
    # together in the pam filter.
    if [ $size_l -eq 1 ]; then
        if [ -n "$OLD_LOTC_FOUND" ]; then
            echo "--pam-filter=&$objectClass_l"${pam_filter}
        else
           echo "&$objectClass_l"${pam_filter}
        fi
    elif [ $size_l -gt 1 ]; then
        if [ -n "$OLD_LOTC_FOUND" ]; then
            echo "--pam-filter=&$objectClass_l(|"${pam_filter}")"
        else
           echo "&$objectClass_l(|"${pam_filter}")"
        fi
    fi

    syslog_message "Exit format_pam_filter()"
}

###############################################################
# Old COMEA script functions, needed for backward compatibility
###############################################################


# Check if old LOTC script exists. 
# If old LOTC script should be used, call it
check_if_old_LOTC_script_exists() {
    syslog_message "Enter check_if_old_LOTC_script_exists()"
    #Checks for the LOTC Version (if Version < R3A04,then it is considered as old Lotc Version)
    LOTC_VERSION_EXISTING=`cat $LOTC_VERSION`
    LOTC_VERSION_NEW="R3A04"
    if [ $LOTC_VERSION_EXISTING \< $LOTC_VERSION_NEW ]; then
        if [ -x $OLD_AUTH_CMD ] ; then
            OLD_LOTC_FOUND="1"
            echo "Old LOTC-script found. Using it."
            # Old file exist, use it and call it.
            parse_opts "$@"
            RC=$?
            if [ $RC != 0 ]; then
               syslog_message "Parse options failed, rc=$RC"
               return $RC
            fi
            check_if_prepare_set
            pam_filter=`format_pam_filter $NODE_TYPE`
            syslog_message "PAM filter=$pam_filter"
            syslog_message "Executing: $OLD_AUTH_CMD $AUTH_TYPE $ARG_LIST $pam_filter"
            exec $OLD_AUTH_CMD $AUTH_TYPE $ARG_LIST $pam_filter
        else
             echo "Failed to find old LOTC script. Exiting. Used args : $AUTH_TYPE $ALL_REAL_ARGS" >> $COMEA_ROOT_DIR/test_log/authentication-method-set_fail.log
            return $ERROR
        fi
    fi
    syslog_message "Exit check_if_old_LOTC_script_exists()"
}

#############################################
# END  Old COMEA script functions
###################################################

# Backup original files to default files
save_default_files() {
    syslog_message "Enter save_default_files()"
    test -e "$OPENLDAP_CONF_DEFAULT"   || cp "$OPENLDAP_CONF" "$OPENLDAP_CONF_DEFAULT"
    if [ -x $OPENLDAP_LDAPRC ]; then
        test -e "$OPENLDAP_LDAPRC_DEFAULT" || cp "$OPENLDAP_LDAPRC" "$OPENLDAP_LDAPRC_DEFAULT"
    fi
    test -e "$LDAP_CONF_DEFAULT"       || cp "$LDAP_CONF" "$LDAP_CONF_DEFAULT"
    test -e "$NSSWITCH_CONF_DEFAULT"   || cp "$NSSWITCH_CONF" "$NSSWITCH_CONF_DEFAULT"
    test -e "$PAM_SSHD_CONF_DEFAULT"   || cp "$PAM_SSHD_CONF" "$PAM_SSHD_CONF_DEFAULT"
    umask 177
    test -e "$LDAP_SECRET_DEFAULT"      || cp "$LDAP_SECRET" "$LDAP_SECRET_DEFAULT"
    umask $DEFAULT_UMASK
    syslog_message "Exit save_default_files()"
}

# Do some semantic checking of arguments to this script.
check_ldap_args() {
    syslog_message "Enter check_ldap_args()"
    if [ -z "$URIS" ]; then
        error "authentication-method-set failed, missing argument --uri"
    fi
    if [ $baseDnUsed != true ]; then
        error "authentication-method-set failed, missing argument --base-dn"
    fi
    if [ -n "$TLS_CLIENT_CERT" -a -z "$TLS_CLIENT_KEY" ]; then
        error "authentication-method-set failed, inconsistent argument list, either both --tls-client-certificate and --tls-client-key or none"
    fi
    if [ -n "$TLS_CLIENT_KEY" -a -z "$TLS_CLIENT_CERT" ]; then
        error "authentication-method-set failed, inconsistent argument list, either both --tls-client-certificate and --tls-client-key or none"
    fi
    syslog_message "Exit check_ldap_args()"
}


# Restart "Name Service Cache Daemon"
# Also clear the caches of passwd and group files of PAM "Name Service Cache Daemon"
restart_nscd() {
    syslog_message "Enter restart_nscd()"
    # Clear group and passwd cache and restart service "Name Service Cache Daemon"
    nscd -i group
    nscd -i passwd
    if service nscd status &> /dev/null; then
       service nscd restart
       RC=$?
       if [ $RC != 0 ]; then
        syslog_message "Error: Restart of nscd failed ($?), rc=$RC"
        return $RC
      fi
    fi
    syslog_message "Exit restart_nscd()"
}

# Create the OpenLDAP client config (/etc/openldap/ldap.conf)
create_openldap_conf_tmp() {
    syslog_message "Enter create_openldap_conf_tmp()"
    # Comment out existing variables in existing config file and append our values at end
    sed    -e 's/^BASE /#&/' \
    -e 's/^URI /#&/' \
    -e 's/^TLS_CACERT /#&/' \
    -e 's/^TLS_CACERTDIR /#&/' \
    -e 's/^TLS_CIPHER_SUITE /#&/' \
    -e 's/^TLS_RANDFILE /#&/' \
    -e 's/^TLS_REQCERT /#&/' \
    -e '/^# End of file/ d' \
    $OPENLDAP_CONF_DEFAULT > $OPENLDAP_CONF_TMP
    (
    echo "$AUTO_MSG"
    echo ""
    echo "BASE $BASE_DN"
    echo "URI $URIS"
    echo ""

    echo "# CA certificates for server certification"
    if [ -n "$TLS_CA_CERT" ]; then
        echo "TLS_CACERT $TLS_CA_CERT"
        echo "TLS_REQCERT demand"
        if [ -n "$TLS_CIPHERS" ]; then
           echo "TLS_CIPHER_SUITE $TLS_CIPHERS"
        fi
    else
        echo "# No CA certificate specified"
        echo "TLS_REQCERT never"
    fi
    if [ -n "$TLS_CACERTDIR" ]; then
        echo "TLS_CACERTDIR $TLS_CACERTDIR"
        if [ -n "$TLS_CIPHERS" ]; then
           echo "TLS_CIPHER_SUITE $TLS_CIPHERS"
        fi
    fi
    echo ""
    echo "# End of file"
    echo ""
    ) >> $OPENLDAP_CONF_TMP
    syslog_message "Exit create_openldap_conf_tmp()"
}


# Create the user specific $HOME/.ldaprc used by OpenLDAP client.
#The client credentials for OpenLDAP tools are placed in an .ldaprc file under the user's home directory.
# $HOME will be for the uid that runs this script, most likely the COM user.
create_openldap_ldaprc_tmp() {
    syslog_message "Enter create_openldap_ldaprc_tmp()"
    # Comment out existing variables in existing config file and append our values at end
    if [ -x "$OPENLDAP_LDAPRC_DEFAULT" ]; then
    sed    -e 's/^TLS_CERT /#&/' \
        -e 's/^TLS_KEY /#&/' \
        -e '/^# End of file/ d' \
        $OPENLDAP_LDAPRC_DEFAULT > $OPENLDAP_LDAPRC_TMP
    fi
    (
    echo "$AUTO_MSG"
    if [ -n "$TLS_CLIENT_CERT" ]; then
        echo "TLS_CERT $TLS_CLIENT_CERT"
        echo "TLS_KEY $TLS_CLIENT_KEY"
    else
        echo "# No client certificate specified"
    fi
    echo "# End of file"
    echo ""
    ) >> $OPENLDAP_LDAPRC_TMP
    syslog_message "Exit create_openldap_ldaprc_tmp()"
}


# Create the system specific ldap.conf (/etc/ldap.conf) used by PAM/NSS
create_ldap_conf_tmp() {
    syslog_message "Enter create_ldap_conf_tmp()"
    # Comment out existing variables in existing config file and append our values at end
    if [ -f "$LDAP_CONF_DEFAULT" ] ; then
    sed    -e "s/^base /#&/" \
    -e "s/^host /#&/" \
    -e "s/^uri /#&/" \
    -e "s/^ldap_version /#&/" \
    -e "s/^pam_login_attribute /#&/" \
    -e "s/^bind_policy /#&/" \
    -e "s/^nss_connect_policy /#&/" \
    -e "s/^bind_time_limit /#&/" \
    -e "s/^bind_dn /#&/" \
    -e "s/^bind_pw /#&/" \
    -e "s/^pam_lookup_policy /#&/" \
    -e "s/^pam_password /#&/" \
    -e "s/^ssl /#&/" \
    -e "s/^tls_cacertfile /#&/" \
    -e "s/^tls_checkpeer /#&/" \
    -e "s/^tls_ciphers /#&/" \
    -e "s/^tls_cert /#&/" \
    -e "s/^tls_key /#&/" \
    -e "s/^scope /#&/" \
    -e "s/^pam_min_uid /#&/" \
    -e "s/^pam_max_uid /#&/" \
    -e "s/^pam_filter /#&/" \
    -e "s/^referrals /#&/" \
    -e '/^# End of file/ d' \
    $LDAP_CONF_DEFAULT > $LDAP_CONF_TMP

    # Make sure /etc/ldap.conf temp file is only readable by owner
    chmod 600 $LDAP_CONF_TMP
    fi
    (
    echo "$AUTO_MSG"
    echo "base $BASE_DN"
    echo "uri $URIS"
    echo ""
    echo "# The LDAP version to use (defaults to 3"
    echo "# if supported by client library)"
    echo "ldap_version 3"
    if [ -n "$BIND_DN" ]; then
        echo "# User to connect to the LDAP as"
        echo "binddn $BIND_DN"
	echo "rootbinddn $BIND_DN"
    fi
    echo ""
    if [ -n "$LOGIN_ATTR" ]; then
        echo "# The user ID attribute"
        echo "pam_login_attribute $LOGIN_ATTR"
        echo ""
    fi
    echo "# Don't try forever if the LDAP server is not reacheable"
    echo "bind_policy soft"
    echo ""
    echo "# Search the root DSE for the password policy (works"
    echo "# with Netscape Directory Server). And make use of"
    echo "# Password Policy LDAP Control (as in OpenLDAP)"
    echo "pam_lookup_policy yes"
    echo ""
    echo "# Hash password locally; required for University of"
    echo "# Michigan LDAP server, and works with Netscape"
    echo "# Directory Server if you're using the UNIX-Crypt"
    echo "# hash mechanism and not using the NT Synchronization"
    echo "# service."
    echo "pam_password exop"
    echo ""
    echo "# OpenLDAP SSL mechanism"
    if [ -n "$ACTIVATE_TLS" ]; then
        echo "# start_tls mechanism uses the normal LDAP port, LDAPS typically 636"
        echo "ssl start_tls"
        echo ""
    else
        echo "# No TLS set for the LDAP servers in the config, not enabling TLS"
        echo "ssl off"
    fi
    echo ""
    echo "# To allow for local password database fall back, set the"
    echo "# time limit for a LDAP bind to 3 second. This will let the"
    echo "# second try to login on a serial console successful."
    echo "bind_timelimit 3"
    echo ""
    echo "# Connection policy:"
    echo "#  persist:   DSA connections are kept open (default)"
    echo "#  oneshot:   DSA connections destroyed after request"
    echo "nss_connect_policy oneshot"
    echo ""
    echo "# CA certificates for server certification"
    if [ -n "$TLS_CA_CERT" ]; then
        echo "tls_cacertfile $TLS_CA_CERT"
        echo "tls_checkpeer yes"
        if [ -n "$TLS_CIPHERS" ]; then
	   echo ""
           echo "# Ciphers to allow when connecting to LDAP server"
           echo "tls_ciphers $TLS_CIPHERS"
           echo ""
        fi
    else
        echo "# No CA certificate specified"
    fi
    if [ -n "$TLS_CLIENT_CERT" -a -n "$TLS_CLIENT_KEY" ]; then
        echo "# Client certificate and key"
        echo "tls_cert $TLS_CLIENT_CERT"
        echo "tls_key $TLS_CLIENT_KEY"
        echo ""
    fi

    echo "# Make sure the scope is to search through sub trees"
    echo "scope sub"
    echo ""

    echo "# Enable automatic referrals"
    echo "referrals yes"
    echo ""

    echo "# For security reasons, the UIDs are limited to the range 1000-65499"
    echo "pam_min_uid 1000"
    echo "pam_max_uid 65499"
    echo ""

    if [ -n "$PAM_FILTER" ]; then
        echo "# PAM filter"
        echo "pam_filter $PAM_FILTER"
        echo ""
    fi
    
    if [ -n "$LDAP_GID" ] ; then
        echo "# Override GID returned by a LDAP lookup"
        echo "nss_override_attribute_value gidNumber $LDAP_GID"
        echo ""
    fi

    if [ -d "$NOHOME" ] ; then
        echo "# Override home directory returned by a LDAP lookup"
        echo "nss_override_attribute_value homeDirectory /home/nohome"
        echo ""
    fi

    echo "# Override login shell returned by a LDAP lookup"
    echo "nss_override_attribute_value loginShell /bin/bash"
    echo ""

    echo "# End of file"
    echo ""
    ) >> $LDAP_CONF_TMP

    umask 177
    (
    if [ -n "$BIND_PASSWORD" ]; then
        echo "$BIND_PASSWORD"
    fi 
    ) > $LDAP_SECRET_TMP
    umask $DEFAULT_UMASK
    syslog_message "Exit create_ldap_conf_tmp()"
}

# Update the nsswitch.conf file. 
# nss_ldap is used to perform all LDAP communications and translations for passwd, shadow and groupi & this can be performed by configuring /etc/nsswitch.conf
# It is pointing out the which order the authentication should be made, ie local files/ldap

update_nsswitch_conf_tmp() {
    syslog_message "Enter update_nsswitch_conf_tmp()"
    # Only add ldap to group if group com-ldap exist
    if [ -z "$LDAP_GID" ] ; then
	ldap="ldap"
    fi

    cp $NSSWITCH_CONF $NSSWITCH_CONF_TMP
    sed -i    -e '/^group:/ s/[[:space:]]*ldap//g' \
    -e "/^group:/ s/$/ ${ldap}/" \
    -e '/^passwd:/ s/[[:space:]]*ldap//g' \
    -e '/^passwd:/ s/$/ ldap/' \
    $NSSWITCH_CONF_TMP
    syslog_message "Exit update_nsswitch_conf_tmp()"
}

# Create the pam SSHD config file. User authentication is attempted in the order specified by the pam.d file of the respective service (e.g., SSH).
# Add so it is using the ldap.so files 
#
# Some options used below and their meaning
# default - all not explicitly mentioned values
# ignore  - Ignore underlying account module regardless of whether the 
#          control flag is required, optional, or sufficient
# new_authtok_reqd - New authentication token required. This is normally 
#                    returned if the machine security policies require that 
#                    the password should be changed beccause the password 
#                    is NULL or it has aged
# success - Successful function return

create_sshd_tmp() {
    syslog_message "Enter create_sshd_tmp()"
    (
    echo "$AUTO_MSG"
# Check if user is in the nologin file. If not, continue
    echo "auth      requisite                     pam_nologin.so"
# Check if user is a local user. "success=2" means: if success, skip next 2 rules 
# If not success, do next rule (do ldap authentication).
    echo "auth      [default=ignore success=2]    pam_localuser.so"
    echo "auth      required     pam_env.so"
# Do LDAP authentication and then exit. 
# if success then pam auth is successful and skip further auth processing
# if fail, exit and fail auth processing
    echo "auth      [success=done new_authtok_reqd=ok ignore=ignore default=die]  pam_ldap.so"
    echo "auth      include      common-auth"
    echo "auth      required     pam_loginallow.so"
    echo ""
    echo "account   sufficient   pam_ldap.so"
    echo "account   include      common-account"
    echo ""
    echo "password  include      common-password"
    echo ""
    echo "session   required     pam_loginuid.so"
    echo "session   include      common-session"
    echo "session   [default=1 success=ignore]    pam_localuser.so"
    echo "session   required     pam_mkhomedir.so"
    ) > $PAM_SSHD_CONF_TMP
    syslog_message "Exit create_sshd_tmp()"
}


# Helper function: Wait for a file to be copied from cluster to local node.
# Wait 2 sec between each try and max 20 sec (com ea wrapper times out after 30)
wait_for_files_to_sync() {
    syslog_message "Enter wait_for_files_to_sync()"
    
    #To check if openldap/ldap.conf is synced.
    local openldapconfsynced=0

    #To check if ldap.conf is synced.
    local ldapconfsynced=0

    #To check if nsswitch.conf is synced.
    local nsswitchconfsynced=0

    #To check if .ldaprc is synced.This should be checked only if useTls is enabled.
    local ldaprcsynced=0 

    #To check if pam.d/sshd is synced
    local pamsshdsynced=0

    #To check if ldap.secret file is synced
    local ldapsecretsynced=0

    x=1
    while [ $x -le 10 ]
    do
       compare_file $openldapconfsynced $CLUSTER_OPENLDAP_CONF $OPENLDAP_CONF
       openldapconfsynced=$?
       compare_file $ldapconfsynced $CLUSTER_LDAP_CONF $LDAP_CONF
       ldapconfsynced=$?
       compare_file $nsswitchconfsynced $CLUSTER_NSSWITCH_CONF $NSSWITCH_CONF
       nsswitchconfsynced=$?
       # Check for .ldaprc if the useTls is enable
       if [ -n "$ACTIVATE_TLS" ] && [ -x $OPENLDAP_LDAPRC ]; then
           compare_file $ldaprcsynced $CLUSTER_OPENLDAP_LDAPRC $OPENLDAP_LDAPRC
           ldaprcsynced=$?
       fi
       compare_file $pamsshdsynced $CLUSTER_PAM_SSHD_CONF $PAM_SSHD_CONF
       pamsshdsynced=$?
       compare_file $ldapsecretsynced $CLUSTER_LDAP_SECRET $LDAP_SECRET
       ldapsecretsynced=$?

       if [ $ldapsecretsynced -eq 1 ] && [ $openldapconfsynced -eq 1 ]; then 
           if [ $pamsshdsynced -eq 1 ] && [ $ldapconfsynced -eq 1 ]; then
              if [ $nsswitchconfsynced -eq 1 ]; then
                  if [ -n "$ACTIVATE_TLS" ] && [ -x $OPENLDAP_LDAPRC ];then
                     if [ $ldaprcsynced -eq 1 ]; then
                         syslog_message "All files have synced."  
                         syslog_message "Exit wait_for_files_to_sync()"
                         return 1
                     else
                         syslog_message "ldaprc not synced. TLS is $ACTIVATE_TLS"
                     fi
                 else
                     syslog_message "All files have synced."
                     syslog_message "Exit wait_for_files_to_sync()"
                     return 1
                fi
             fi
          fi
        fi
        
        sleep 1
        x=`expr $x + 1 `
    done
    if [ $x -gt 10 ]
    then
	syslog_message "Warning: Failed to sync within time limit of 10 sec."
        syslog_message "Exit wait_for_files_to_sync()"
        return 0
    fi
}

#Compare remote and local files.
compare_file() {
    if [ $1 -eq 0 ]; then
       # To check if the remote cluster file exists. No meaning to compare if file not found.
       if ! [ -f $2 ]; then
           error_noexit "File $2 does not exist and can therefore not be synced."
           return 1      
       fi
 
       if cmp -s "$2" "$3"; then
           syslog_message "File $3 synced"
           return 1
       else
           return 0
       fi
    else
        return 1
    fi
}


# Set ldap value in the final temp config files and restart "Name Service Cache Daemon"
set_ldap_config() {
    syslog_message "Enter set_ldap_config()"
    # Set ldap config
    create_openldap_conf_tmp
    create_openldap_ldaprc_tmp
    create_ldap_conf_tmp
    update_nsswitch_conf_tmp
    create_sshd_tmp

    # Move temporary files to remote location
    mv -f $OPENLDAP_CONF_TMP $CLUSTER_OPENLDAP_CONF
    mv -f $LDAP_CONF_TMP $CLUSTER_LDAP_CONF
    mv -f $NSSWITCH_CONF_TMP $CLUSTER_NSSWITCH_CONF
    mv -f $OPENLDAP_LDAPRC_TMP $CLUSTER_OPENLDAP_LDAPRC
    mv -f $PAM_SSHD_CONF_TMP $CLUSTER_PAM_SSHD_CONF
    mv -f $LDAP_SECRET_TMP $CLUSTER_LDAP_SECRET

    # Wait for all files to be synced. 
    wait_for_files_to_sync 
   
    # Restart nscd if all files have synced. 
    if [ $? != 0 ]; then 
        # Restart "Name Service Cache Daemon"
        syslog_message "restarting name service cache daemon"
        restart_nscd
    else
        error_noexit "ldap config files have not synced so nscd is not restarted"
    fi
    syslog_message "Exit set_ldap_config()"
}


# Restore the default config and restart "Name Service Cache Daemon".Restores all the dafault configuration files(i.e., syncd.conf,ldap.conf,ldaprc,nsswitch.conf,sshd) & restarts "Name Service Cache Daemon".
set_default_config() {
    syslog_message "Enter set_default_config()"
    # Set default config
    

    cp $LDAP_CONF_DEFAULT $CLUSTER_LDAP_CONF
    cp $OPENLDAP_CONF_DEFAULT $CLUSTER_OPENLDAP_CONF
    if [ -x "$OPENLDAP_LDAPRC_DEFAULT" ]; then
        cp $OPENLDAP_LDAPRC_DEFAULT $CLUSTER_OPENLDAP_LDAPRC
    fi
    cp $NSSWITCH_CONF_DEFAULT $CLUSTER_NSSWITCH_CONF
    cp $PAM_SSHD_CONF_DEFAULT $CLUSTER_PAM_SSHD_CONF
    cp $LDAP_SECRET_DEFAULT $CLUSTER_LDAP_SECRET


    # Wait for all files to be synced.
    wait_for_files_to_sync

    # Restore syncd and restart nscd if all files are synced.
    if [ $? != 0 ]; then

        # Restore and restart syncd
        restore_syncd
        syslog_message "restarting synchronization daemon"
        restart_syncd

        # Restart "Name Service Cache Daemon"
        syslog_message "restarting name service cache daemon"
        restart_nscd
    else
        error_noexit "ldap config files have not synced so syncd cannot be restored and restarted."
    fi
    syslog_message "Exit set_default_config()"
   
}


# Read settings from file and set the values in the final files.
apply_config() {
    syslog_message "Enter apply_config()"
    if [ "$AUTH_TYPE" = "ldap" ]; then
        set_ldap_config
    elif [ "$AUTH_TYPE" = "default" ]; then
        set_default_config
    else
        error "Unknown AUTH_TYPE: '$AUTH_TYPE'"
        exit_now $ERROR
    fi
    syslog_message "Exit apply_config()"
}


# For testing
# Check if prepare was given, then print args to a file and exit.
check_if_prepare_set() {
    syslog_message "Enter check_if_prepare_set()"
    if [ $PREPARE -eq 1 ]; then 
        if [ -n $COMEA_ROOT_DIR ]; then
            echo "$AUTH_TYPE $ALL_REAL_ARGS" >> $COMEA_ROOT_DIR/test_log/authentication-method-set_prepare.log
	    PREPARE=0
        fi
	syslog_message "Exit check_if_prepare_set() (exit 0)"
        exit_now 0
    fi
    syslog_message "Exit check_if_prepare_set()"
}

# Add the script's syncd entries to the syncd.conf file and restart syncd
# syncd.conf file controls authentication, access, logging, available modules.
# 4th argument i.e., update_remote when true updates the remote syncd.conf & doesnt update when false.
# 5th argument i.e., control_only when true 
set_syncd_config() {
    syslog_message "Enter set_syncd_config()"
    # Restore file from file-entries created by this script. 
    restore_syncd

    # Add files to be synced.
    ADD_NEWLINE=0
    add_syncd_entry "OpenLDAP Configuration" $OPENLDAP_CONF $CLUSTER_OPENLDAP_CONF "false" "false" ""
    add_syncd_entry "LDAP Configuration" $LDAP_CONF $CLUSTER_LDAP_CONF "false" "false" ""
    add_syncd_entry "NS Switch Configuration" $NSSWITCH_CONF $CLUSTER_NSSWITCH_CONF "false" "false" ""
    add_syncd_entry "COM User Ldaprc File Configuration" $OPENLDAP_LDAPRC $CLUSTER_OPENLDAP_LDAPRC "false" "false" ""
    add_syncd_entry "PAM SSHD Configuration" $PAM_SSHD_CONF $CLUSTER_PAM_SSHD_CONF "false" "false" ""
    add_syncd_entry "LDAP Secret" $LDAP_SECRET $CLUSTER_LDAP_SECRET "false" "false" ""

    # Restart syncd
    restart_syncd
    syslog_message "Exit set_syncd_config() (rc=0)"
    return 0
}


# Add a syncd entry to /etc/syncd.conf file
add_syncd_entry() {
    syslog_message "Enter add_syncd_entry()"
    if [ "$4" != "true" ] && [ "$4" != "false" ]; then
       error "Argument $4 need to be either true or false"
       return $ERROR
    fi

    if [ "$5" != "true" ] && [ "$5" != "false" ]; then
       error "Argument $5 need to be either true or false"
       return $ERROR
    fi

    if [ ! -x $6 ]; then
       error "File $6 does not exist, or isn't executable"
       return $ERROR
    fi

    # Don't add newline for first append.
    if [ $ADD_NEWLINE -eq 1 ]; then
       /bin/echo -e "\n"                          >> $SYNCD_CONF
    else
       /bin/echo -e -n "\n"                       >> $SYNCD_CONF
       ADD_NEWLINE=1
    fi
    echo "file {"                            >> $SYNCD_CONF
    /bin/echo -e "\tdescription    = \""$1"\","   >> $SYNCD_CONF
    /bin/echo -e "\tlocal          = \""$2"\","   >> $SYNCD_CONF
    /bin/echo -e "\tremote         = \""$3"\","   >> $SYNCD_CONF
    /bin/echo -e "\tupdate_remote  = $4,"         >> $SYNCD_CONF
    /bin/echo -e "\tcontrol_only   = $5,"         >> $SYNCD_CONF
    /bin/echo -e "\tlocal_update_cmd = \""$6"\""  >> $SYNCD_CONF
    /bin/echo -n "}"                              >> $SYNCD_CONF
       
    syslog_message "Exit add_syncd_entry() (rc=0)"
    return 0
}

# Add entries in syncd.conf and remove duplicate entries
# File is copied to /tmp to avoid growing syncd.conf if the uid runningn this script's has no write permission in /tmp.
restore_syncd() {
    syslog_message "Enter restore_syncd()"
    SED_FILTER_EXPR="sed -e 's/\//\\\ \//g' | sed -e 's/ //g' | sed -e 's/\./\\\./g'"

    # Add escape character before '/' and '.' to make the path fit into the sed expression.
    SED_LOCAL_OPENLDAP_CONF=`echo $OPENLDAP_CONF | eval $SED_FILTER_EXPR`
    SED_REMOTE_OPENLDAP_CONF=`echo $CLUSTER_OPENLDAP_CONF | eval $SED_FILTER_EXPR`
    SED_LOCAL_OPENLDAP_LDAPRC=`echo $OPENLDAP_LDAPRC | eval $SED_FILTER_EXPR`
    SED_REMOTE_OPENLDAP_LDAPRC=`echo $CLUSTER_OPENLDAP_LDAPRC | eval $SED_FILTER_EXPR`
    SED_LOCAL_LDAP_CONF=`echo $LDAP_CONF | eval $SED_FILTER_EXPR`
    SED_REMOTE_CLUSTER_LDAP_CONF=`echo $CLUSTER_LDAP_CONF | eval $SED_FILTER_EXPR`
    SED_LOCAL_NSSWITCH_CONF=`echo $NSSWITCH_CONF | eval $SED_FILTER_EXPR`
    SED_REMOTE_NSSWITCH_CONF=`echo $CLUSTER_NSSWITCH_CONF | eval $SED_FILTER_EXPR`
    SED_LOCAL_PAM_SSHD_CONF=`echo $PAM_SSHD_CONF | eval $SED_FILTER_EXPR`
    SED_REMOTE_PAM_SSHD_CONF=`echo $CLUSTER_PAM_SSHD_CONF | eval $SED_FILTER_EXPR`
    SED_LOCAL_LDAP_SECRET=`echo $LDAP_SECRET | eval $SED_FILTER_EXPR`
    SED_REMOTE_CLUSTER_LDAP_SECRET=`echo $CLUSTER_LDAP_SECRET | eval $SED_FILTER_EXPR`

    SYNCD_CONF_TMP="`mktemp`"
    # Read 7 lines after the 'file' keyword and remove the file-clause based on
    # contents of local and remote file name. 
    # Remove identical consecutive newlines in file.
    # Remove trailing newline in file.
    cat $SYNCD_CONF | \
	eval "sed -e '{/^file/ {N;N;N;N;N;N;N; /file[ \t\n]*{.*local[ \t]*=[ \t]*\"$SED_LOCAL_OPENLDAP_CONF.*remote[ \t]*=[ \t]*\"$SED_REMOTE_OPENLDAP_CONF.*}/d}}'" | \
	eval "sed -e '{/^file/ {N;N;N;N;N;N;N; /file[ \t\n]*{.*local[ \t]*=[ \t]*\"$SED_LOCAL_OPENLDAP_LDAPRC.*remote[ \t]*=[ \t]*\"$SED_REMOTE_OPENLDAP_LDAPRC.*}/d}}'" | \
	eval "sed -e '{/^file/ {N;N;N;N;N;N;N; /file[ \t\n]*{.*local[ \t]*=[ \t]*\"$SED_LOCAL_LDAP_CONF.*remote[ \t]*=[ \t]*\"$SED_REMOTE_CLUSTER_LDAP_CONF.*}/d}}'" | \
	eval "sed -e '{/^file/ {N;N;N;N;N;N;N; /file[ \t\n]*{.*local[ \t]*=[ \t]*\"$SED_LOCAL_NSSWITCH_CONF.*remote[ \t]*=[ \t]*\"$SED_REMOTE_NSSWITCH_CONF.*}/d}}'" | \
	eval "sed -e '{/^file/ {N;N;N;N;N;N;N; /file[ \t\n]*{.*local[ \t]*=[ \t]*\"$SED_LOCAL_PAM_SSHD_CONF.*remote[ \t]*=[ \t]*\"$SED_REMOTE_PAM_SSHD_CONF.*}/d}}'" | \
	eval "sed -e '{/^file/ {N;N;N;N;N;N;N; /file[ \t\n]*{.*local[ \t]*=[ \t]*\"$SED_LOCAL_LDAP_SECRET.*remote[ \t]*=[ \t]*\"$SED_REMOTE_CLUSTER_LDAP_SECRET.*}/d}}'" | \
	sed -e '$!N; /^\(.*\)\n\1$/!P; D' | \
	sed -e '${/^$/d}' > $SYNCD_CONF_TMP

    cp $SYNCD_CONF_TMP $SYNCD_CONF
    rm $SYNCD_CONF_TMP
    syslog_message "Exit restore_syncd()"
}

# Restart the syncd daemon so it will re-read the added syncd.conf changes
restart_syncd() {
   syslog_message "Restarting synchronization daemon"
   # Clear group and passwd cache and restart service syncd
   if service lde-syncd status &> /dev/null; then
      service lde-syncd restart
      RC=$?
      if [ $RC != 0 ]; then
        syslog_message "Error: Restart of syncd failed ($?), rc=$RC"
        return $RC
      fi 
   fi
}


# Parse options known
parse_opts() {
    syslog_message "Enter parse_opts()"
    # Prepare getopt
    GETOPT="`which getopt 2>/dev/null`"
    readonly GETOPT="${GETOPT:=/usr/bin/getopt}"
    [ -x "${GETOPT}" ] || error "authentication-method-set failed, missing ${GETOPT} or is not executable"
    readonly PROGNAME="${0##*/}"

    lopts='prepare,nodeType:,base-dn:,bind-dn:,bind-password:,login-attribute:,tls-ca-certificate:,tls-client-certificate:,tls-client-key:,uri:,useTls'
    args="`${GETOPT} -n ${PROGNAME} -l ${lopts} "" $@`"
    if [ $? != 0 ]; then
	syslog_message "Error: getopt failed ($?), rc=$ERROR"
	return $ERROR
    fi

    set -- ${args}
    if [ -n "$OLD_LOTC_FOUND" ]; then
     while true; do
        case "$1" in
        --prepare)
            PREPARE=1
            break
            ;;
        --nodeType)
            NODE_TYPE="$(echo $2 | tr -d "'")"
            shift
            ;;
        --)
            # End, if parameter list finished
            break
            ;;
        --useTls)
            # No way to detect if it is a single-option or value-option, so this needs to be added for all no-value-options
            ARG_LIST=$ARG_LIST" $1"
            ;;
        *)
            # Save the remaining args in ARG_LIST
            # Option with argument, copy valuename and value
            # Remove ' and add =
            ARG_LIST=$ARG_LIST" $1=$(echo $2 | tr -d "'")"
            shift
            ;;
        esac
            shift
    done
   else
    while true; do
        case "$1" in
            --prepare)
                PREPARE=1
                break
                ;;
            --nodeType)
                NODE_TYPE="`echo $2 | tr -d "'"`"
                shift
                ;;
            --base-dn)
	        baseDnUsed=true
                BASE_DN="`echo $2 | tr -d "'"`"
                shift
                ;;
            --bind-dn)
                BIND_DN="`echo $2 | tr -d "'"`"
                shift
                ;;
            --bind-password)
                BIND_PASSWORD="`echo $2 | tr -d "'"`"
                shift
                ;;
            --login-attribute)
                LOGIN_ATTR="`echo $2 | tr -d "'"`"
                shift
                ;;
            --tls-ca-certificate)
                TLS_CA_CERT="`echo $2 | tr -d "'"`"
                shift
                ;;
            --tls-client-certificate)
                TLS_CLIENT_CERT="`echo $2 | tr -d "'"`"
                shift
                ;;
            --tls-client-key)
                TLS_CLIENT_KEY="`echo $2 | tr -d "'"`"
                shift
                ;;
            --useTls)
                ACTIVATE_TLS=true
                ;;
            --uri)
                NEW_URI="`echo $2 | tr -d "'"`"
                if [ -z $URIS ]; then
                    URIS=$NEW_URI
                else
                    URIS="$URIS $NEW_URI"
                fi
                shift
                ;;
            --)
                # End of parameter list
                break
                ;;
            *)
                error "Unknown parameter: '$1'"
                shift
                ;;
            esac
                shift
    done
    syslog_message "Exit parse_opts()"
fi
}


# Main 
# Check if old LOTC script should be used.
# Parse command line options
# Check if prepare was specified, then exit.
# Save old default files
# If default is specified, then apply default settings.
# Create Pam-filters from nodetypes
# Create new temp files
# Create syncd.conf
# Apply new config 
main() {
    syslog_message "Command: $*"
    syslog_message "Enter main()"
    # shift away "authentication"
    shift

    #shift away "ldap" or "default"
    AUTH_TYPE="$1"
    shift

    # For testing
    # Save the script arguments for debug AND local FT test case
    ALL_REAL_ARGS="$@"

    # Check if old LOTC, then use it 
    check_if_old_LOTC_script_exists "$@"
    RC=$?
    if [ $RC != 0 ]; then 
       syslog_message "Checking if old LOTC script exists, rc=$RC"
       return $RC
    fi

    # No old LOTC, do normal process
    # Parse the COM EA options
    parse_opts "$@"
    RC=$?
    if [ $RC != 0 ]; then
       syslog_message "Parsing options, rc=$RC"
       return $RC
    fi

    check_if_prepare_set

    # Always check that the default files are saved
    save_default_files

    if [ "$AUTH_TYPE" = "default" ]; then
	apply_config
        syslog_message "Exit main() (exit 0)"
        exit_now 0
    fi
    if [ "$AUTH_TYPE" != "ldap" ]; then
        error "authentication-method-set failed, missing argument <authentication-type>"
    fi

    PAM_FILTER=`format_pam_filter $NODE_TYPE`
    check_ldap_args
    set_syncd_config
    apply_config
    syslog_message "Exit main()"
}

syslog_message "ETC_DIR=$ETC_DIR"
syslog_message "CLUSTER_ETC_DIR=$CLUSTER_ETC_DIR"
syslog_message "ACTIVATE_TLS=$ACTIVATE_TLS"

main "$@"
#exit 0
