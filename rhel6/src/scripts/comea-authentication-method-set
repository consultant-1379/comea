#!/bin/sh
#
# Copyright (c) 2012 - 2014 Ericsson AB.
# All rights reserved.
#
# The information in this document is the property of Ericsson.
# Except as specifically authorized in writing by Ericsson, the
# receiver of this document shall keep the information contained
# herein confidential and shall protect the same in whole or in
# part from disclosure and dissemination to third parties.
# Disclosure and dissemination to the receiver's employees shall
# only be made on a strict need to know basis.
#

# The script is designed to work in a limited linux environment where the support of certain utilities
# like for instance ps and pgrep varies.
# This is a bourne shell script and is free from any non compatible syntax (e.g bash specific features)

#
# Function:     comea-authentication-method-set <authentication-type>..
# Availability: control nodes
#
# <authentication-type> is set to either 'default' or 'ldap', and in the
# latter case the <--sub-arg=value>:s are used to specify ldap details.
#
# 'ldap' sets the variables to make COM use LDAP for authentication and authorization of users.
# 'default' will reset the authentication settings to the default.
# This is described in the document COM EA SPI Programmer's Guide
#
# Return values:
#   0  - if everything is ok.
#   ERROR - if something fails.
#
# NOTE :- In order to avoid the alignment of backup files with UMASK 007, use -p option
# with copy command to preserve original file permissions

# Script debug
#set -x

DEFAULT_UMASK=`umask`
NOHOME=${COMEA_ROOT_DIR}/home/nohome
PREPARE=0

# Auto-generation message
AUTO_MSG="# Entries below auto-generated by 'comea-authentication-method-set'"

# Directory variables. (For COM testing: Don't change these two env variable names)
ETC_DIR="/etc"
CLUSTER_ETC_DIR="/cluster/etc"

# Enabling debug logs to syslog 0=disabled , 1=enabled (error logs will always be written to syslog).
DO_SYSLOG=0

# Workaround for bug in CMW start of com. Sets wrong value in $HOME
# TODO: CMW TR # xxxx ? Create a COM TR for same problem
# This line should be deleted when fixed in OpenSAF
MYUSER="`id -u -n`"
HOME="`grep ${MYUSER} /etc/passwd | cut -d ":" -f6 `"
# End workaround 

# Create necessary test directories on cluster for syncd.
if [ ! -d $CLUSTER_ETC_DIR/pam.d ]; then
   mkdir -p $CLUSTER_ETC_DIR/pam.d
fi

readonly ERROR=1
ADD_NEWLINE=0

# Old LOTC script path
OLD_AUTH_CMD=${COMEA_ROOT_DIR}/usr/lib/cmwea/authentication-method-set

PAM_DIR="$ETC_DIR/pam.d"
PAM_GENFILE_DIR="$ETC_DIR/pam.d"
CLUSTER_PAM_DIR="$CLUSTER_ETC_DIR/pam.d"

ETC_GENFILE_DIR="$ETC_DIR"

HOME_DIR="$HOME"
HOME_GENFILE_DIR="$HOME_DIR"

# File variables
LDAP_CONF="$ETC_DIR/ldap.conf"
LDAP_CONF_DEFAULT="$ETC_GENFILE_DIR/.ldap.conf.default"
LDAP_CONF_TMP="$ETC_GENFILE_DIR/.ldap.conf.tmp"
CLUSTER_LDAP_CONF="$CLUSTER_ETC_DIR/ldap.conf"

NSSWITCH_CONF="$ETC_DIR/nsswitch.conf"
NSSWITCH_CONF_DEFAULT="$ETC_GENFILE_DIR/.nsswitch.conf.default"
NSSWITCH_CONF_TMP="$ETC_GENFILE_DIR/.nsswitch.conf.tmp"
CLUSTER_NSSWITCH_CONF="$CLUSTER_ETC_DIR/nsswitch.conf"

PAM_SSHD_CONF="$PAM_DIR/sshd"
PAM_SSHD_CONF_DEFAULT="$PAM_GENFILE_DIR/.sshd.default"
PAM_SSHD_CONF_TMP="$PAM_GENFILE_DIR/.sshd.tmp"
CLUSTER_PAM_SSHD_CONF="$CLUSTER_PAM_DIR/sshd"

PAM_SYSTEMD_USER_CONF="$PAM_DIR/systemd-user"
PAM_SYSTEMD_USER_CONF_DEFAULT="$PAM_GENFILE_DIR/.systemd-user.default"
PAM_SYSTEMD_USER_CONF_TMP="$PAM_GENFILE_DIR/.systemd-user.tmp"
CLUSTER_PAM_SYSTEMD_USER_CONF="$CLUSTER_PAM_DIR/systemd-user"

SYNCD_CONF="$ETC_DIR/syncd.conf"

# Script internal return values
# Note: These return values are only used internally by the
#       script and must not be returned by the script itself.
# Internal error = 90
readonly INTERNAL_ERROR=90
# syncd already stopped = 91
readonly INTERNAL_SYNCD_ALREADY_STOPPED=91


# Argument variables
DEFAULT_TLS_CIPHERS="ALL:!aNULL:!eNULL:!DES:@STRENGTH"
TLS_CIPHERS=

# Will be set if TLS should be started
#ACTIVATE_TLS=

# Will be set if referrals should be enabled
#ACTIVATE_REFERRALS=

# Will be set to STARTTLS or LDAPS
TLS_MODE=

# Ignore re-setting default during boot
#IGNORE_SET_DEFAULT=

# If the group com-ldap is defined in /etc/group, the GID will override the
# GID returned by the LDAP server
LDAP_GID=`grep ^com-ldap ${COMEA_ROOT_DIR}/etc/group | awk -F':' '{print $3}'`

#To check the mandatory attibute baseDn is given or not
baseDnUsed=false

# This function logs debug messages to syslog if DO_SYSLOG flag is enabled.
syslog_debug_message() {
    if [ $DO_SYSLOG -eq 1 ]; then
	    logger -p local0.debug -t "`basename $0`[$$]" "$*"
    fi
}

# This function logs error messages to syslog and stderr.
syslog_error_message() {
    echo "ER $*" >&2
	logger -p local0.err -t "`basename $0`[$$]" "$*"
}

isTlsdExists=false
if [ -f $PAM_DIR/com-tlsd ] ; then
    PAM_TLSD_CONF="$PAM_DIR/com-tlsd"
    PAM_TLSD_CONF_DEFAULT="$PAM_GENFILE_DIR/.com-tlsd.default"
    PAM_TLSD_CONF_TMP="$PAM_GENFILE_DIR/.com-tlsd.tmp"
    isTlsdExists=true
    syslog_debug_message "TLSD pam config file exists"
else
    syslog_debug_message "TLSD pam config file does not exists"
fi

# This function adds the pam filter based on the node type(s).
# It fill add a part to the filter, e.g, (ericssonUserAuthenticationScope=nodeType01.location1)
# for each node type.Each node type is separated by the delimiter ":".
format_pam_filter() {
    syslog_debug_message "Enter format_pam_filter()"

    objectClass_l="(objectClass=posixAccount)"
    nodetype_l="$1"
    size_l=0

    #Inter-Field-Seperator should be changed to ':' for time being and restored back.
    #else, nodetype values with white-spaces will not be handled correcly.
    IFS_TEMP=$IFS
    IFS=":"
    for nt in $nodetype_l; do
      pam_filter=$pam_filter`echo "(ericssonUserAuthenticationScope="${nt}")"`
      size_l=`expr $size_l + 1`
    done
    IFS="$IFS_TEMP"


    # If more than one filter is specified, they will be OR:ed
    # together in the pam filter.
    if [ $size_l -eq 1 ]; then
        if [ -n "$OLD_LOTC_FOUND" ]; then
            echo "--pam-filter=&$objectClass_l"${pam_filter}
        else
           echo "&$objectClass_l"${pam_filter}
        fi
    elif [ $size_l -gt 1 ]; then
        if [ -n "$OLD_LOTC_FOUND" ]; then
            echo "--pam-filter=&$objectClass_l(|"${pam_filter}")"
        else
           echo "&$objectClass_l(|"${pam_filter}")"
        fi
    fi

    syslog_debug_message "Exit format_pam_filter()"
}

###############################################################
# Old COMEA script functions, needed for backward compatibility
###############################################################


# Check if old LOTC script exists.
# If old LOTC script should be used, call it
check_if_old_LOTC_script_exists() {
    syslog_debug_message "Enter check_if_old_LOTC_script_exists()"
    CMWEA_CMD=${COMEA_ROOT_DIR}/usr/bin/cmwea
    if [ -x $CMWEA_CMD ] ; then
        OLD_LOTC_AUTH_METHOD=`${CMWEA_CMD} | grep authentication-method-set`
        if [ ! -z "$OLD_LOTC_AUTH_METHOD" ] ; then
            if [ -x $OLD_AUTH_CMD ] ; then
                OLD_LOTC_FOUND="1"
                echo "Old LOTC-script found. Using it."
                # Old file exist, use it and call it.
                parse_opts "$@"
                RC=$?
                if [ $RC -ne 0 ]; then
                    syslog_debug_message "Parse options failed, rc=$RC"
                    return $RC
                fi
                check_if_prepare_set
                pam_filter=`format_pam_filter "$NODE_TYPE"`
                syslog_debug_message "PAM filter=$pam_filter"
                syslog_debug_message "Executing: $OLD_AUTH_CMD $AUTH_TYPE $ARG_LIST $pam_filter"
                exec $OLD_AUTH_CMD $AUTH_TYPE $ARG_LIST $pam_filter
            else
                echo "Failed to find old LOTC script. Exiting. Used args : $AUTH_TYPE $ALL_REAL_ARGS" >> $COMEA_ROOT_DIR/test_log/authentication-method-set_fail.log
                return $ERROR
            fi
        fi
    fi
    syslog_debug_message "Exit check_if_old_LOTC_script_exists()"
}

#############################################
# END  Old COMEA script functions
###################################################

# Backup original files to default files
save_default_files() {
    syslog_debug_message "Enter save_default_files()"
    test -e "$LDAP_CONF_DEFAULT"               || cp -p "$LDAP_CONF" "$LDAP_CONF_DEFAULT"
    test -e "$NSSWITCH_CONF_DEFAULT"           || cp -p "$NSSWITCH_CONF" "$NSSWITCH_CONF_DEFAULT"
    test -e "$PAM_SSHD_CONF_DEFAULT"           || cp -p "$PAM_SSHD_CONF" "$PAM_SSHD_CONF_DEFAULT"
    test -e "$PAM_SYSTEMD_USER_CONF_DEFAULT"   || cp -p "$PAM_SYSTEMD_USER_CONF" "$PAM_SYSTEMD_USER_CONF_DEFAULT"
    if [ $isTlsdExists = true ] ; then
        test -e "$PAM_TLSD_CONF_DEFAULT"   || cp -p "$PAM_TLSD_CONF" "$PAM_TLSD_CONF_DEFAULT"
    fi
    syslog_debug_message "Exit save_default_files()"
}

# Do some semantic checking of arguments to this script.
check_ldap_args() {
    syslog_debug_message "Enter check_ldap_args()"
    if [ -z "$URIS" ]; then
        syslog_error_message "authentication-method-set failed, missing argument --uri"
        exit $ERROR
    fi
    if [ $baseDnUsed != true ]; then
        syslog_error_message "authentication-method-set failed, missing argument --base-dn"
        exit $ERROR
    fi
    if [ -n "$TLS_CLIENT_CERT" -a -z "$TLS_CLIENT_KEY" ]; then
        syslog_error_message "authentication-method-set failed, inconsistent argument list, either both --tls-client-certificate and --tls-client-key or none"
        exit $ERROR
    fi
    if [ -n "$TLS_CLIENT_KEY" -a -z "$TLS_CLIENT_CERT" ]; then
        syslog_error_message "authentication-method-set failed, inconsistent argument list, either both --tls-client-certificate and --tls-client-key or none"
        exit $ERROR
    fi
    if [ -n "$TLS_MODE" -a -z "$ACTIVATE_TLS" ]; then
        syslog_error_message "authentication-method-set failed, inconsistent argument list, --tls-mode but not --useTls"
        exit $ERROR
    fi
    if ! [ -z "$TLS_MODE" -o "$TLS_MODE" = "STARTTLS" -o "$TLS_MODE" = "LDAPS" ]; then
    	syslog_error_message "authentication-method-set failed, incorrect value of --tls-mode, allowed values are STARTTLS or LDAPS"
        exit $ERROR
    fi
    
    syslog_debug_message "Exit check_ldap_args()"
}


# Restart "Name Service Cache Daemon"
# Also clear the caches of passwd and group files of PAM "Name Service Cache Daemon"
restart_nscd() {
    syslog_debug_message "Enter restart_nscd()"
    
    # Check if nscd is running, otherwise log error.
    service nscd status > /dev/null 2>&1
    RC=$?
    if [ $RC -eq 3 ] ; then
       syslog_error_message "Error: nscd is not running and will not be restarted, nscd status returned $RC"        
    else
       # Clear group and passwd cache and restart service "Name Service Cache Daemon"
       # Clear group cache
       nscd -i group
       RC=$?
       if [ $RC -ne 0 ] ; then
          syslog_error_message "Error: Clear nscd group cache failed, rc=$RC"        
       fi
       # Clear passwd cache
       nscd -i passwd
       RC=$?
       if [ $RC -ne 0 ] ; then
          syslog_error_message "Error: Clear nscd passwd cache failed, rc=$RC"        
       fi
       # Restart nscd
       service nscd restart > /dev/null 2>&1
       RC=$?
       if [ $RC -ne 0 ] ; then
          syslog_error_message "Error: Restart of nscd failed, nscd restart returned $RC"
       fi  
    fi
    syslog_debug_message "Exit restart_nscd()"
}

# Create the system specific ldap.conf (/etc/ldap.conf) used by PAM/NSS
create_ldap_conf_tmp() {
    syslog_debug_message "Enter create_ldap_conf_tmp()"
    # Remove existing variables in existing config file and add our values at end
    if [ -f "$LDAP_CONF_DEFAULT" ] ; then
    sed    -e " /^base / d" \
    -e " /^host / d" \
    -e " /^uri / d" \
    -e " /^ldap_version / d" \
    -e " /^pam_login_attribute / d" \
    -e " /^bind_policy / d" \
    -e " /^nss_connect_policy / d" \
    -e " /^bind_time_limit / d" \
    -e " /^bind_dn / d" \
    -e " /^bind_pw / d" \
    -e " /^pam_lookup_policy / d" \
    -e " /^pam_password / d" \
    -e " /^ssl / d" \
    -e " /^tls_cacertfile / d" \
    -e " /^tls_cacertdir / d" \
    -e " /^tls_checkpeer / d" \
    -e " /^tls_ciphers / d" \
    -e " /^tls_cert / d" \
    -e " /^tls_key / d" \
    -e " /^scope / d" \
    -e " /^pam_min_uid / d" \
    -e " /^pam_max_uid / d" \
    -e " /^pam_filter / d" \
    -e " /^referrals / d" \
    -e ' /^# End of file/ d' \
    $LDAP_CONF_DEFAULT > $LDAP_CONF_TMP

    fi
    (
    echo "$AUTO_MSG"
    echo "base $BASE_DN"
    echo "uri $URIS"
    echo ""
    echo "# The LDAP version to use (defaults to 3"
    echo "# if supported by client library)"
    echo "ldap_version 3"
    if [ -n "$BIND_DN" ]; then
        echo "# User to connect to the LDAP as"
        echo "binddn $BIND_DN"
        if [ -n "$PASSWORD_FILE" ]; then
            if [ -e "$PASSWORD_FILE" ]; then
                echo "bindpw `cat $PASSWORD_FILE`"
            else
                syslog_error_message "Bind password file not found: $PASSWORD_FILE"
                exit $ERROR
            fi
        fi
    fi
    echo ""
    if [ -n "$LOGIN_ATTR" ]; then
        echo "# The user ID attribute"
        echo "pam_login_attribute $LOGIN_ATTR"
        echo ""
    fi
    echo "# Don't try forever if the LDAP server is not reacheable"
    echo "bind_policy soft"
    echo ""
    echo "# Search the root DSE for the password policy (works"
    echo "# with Netscape Directory Server). And make use of"
    echo "# Password Policy LDAP Control (as in OpenLDAP)"
    echo "pam_lookup_policy yes"
    echo ""
    echo "# Hash password locally; required for University of"
    echo "# Michigan LDAP server, and works with Netscape"
    echo "# Directory Server if you're using the UNIX-Crypt"
    echo "# hash mechanism and not using the NT Synchronization"
    echo "# service."
    echo "pam_password exop"
    echo ""
    echo "# OpenLDAP SSL mechanism"
    if [ -n "$ACTIVATE_TLS" ]; then
        if [ "$TLS_MODE" = "LDAPS" ]; then
            echo "# TLS only towards specified port included in the uri."
            echo "ssl on"
        else
            # STARTTLS. Also default if --useTls was specifed and no --tls-mode
        echo "# start_tls mechanism uses the normal LDAP port, LDAPS typically 636"
        echo "ssl start_tls"
        fi
        echo ""
    else
        echo "# No TLS set for the LDAP servers in the config, not enabling TLS"
        echo "ssl off"
    fi
    echo ""
    echo "# To allow for local password database fall back, set the"
    echo "# time limit for a LDAP bind to 11 second. This will let the"
    echo "# second try to login on a serial console successful."
    echo "bind_timelimit 11"
    echo ""
    echo "# Connection policy:"
    echo "#  persist:   DSA connections are kept open (default)"
    echo "#  oneshot:   DSA connections destroyed after request"
    echo "nss_connect_policy oneshot"
    echo ""
    echo "# CA certificates for server certification"
    if [ -n "$TLS_CA_CERT" ]; then
        echo "tls_cacertfile $TLS_CA_CERT"
    fi
    if [ -n "$TLS_CA_CERT_DIR" ]; then
        echo "tls_cacertdir $TLS_CA_CERT_DIR"
    fi
    if [ -n "$TLS_CA_CERT" ] || [ -n "$TLS_CA_CERT_DIR" ]; then
        echo "tls_checkpeer yes"
        if [ -n "$TLS_CIPHERS" ]; then
           echo ""
           echo "# Ciphers to allow when connecting to LDAP server"
           echo "tls_ciphers $TLS_CIPHERS"
           echo ""
        fi
    else
        echo "# No CA certificate specified"
    fi
    if [ -n "$TLS_CLIENT_CERT" -a -n "$TLS_CLIENT_KEY" ]; then
        echo "# Client certificate and key"
        echo "tls_cert $TLS_CLIENT_CERT"
        echo "tls_key $TLS_CLIENT_KEY"
        echo ""
    fi

    echo "# Make sure the scope is to search through sub trees"
    echo "scope sub"
    echo ""

    # Referrals
    if [ -n "$ACTIVATE_REFERRALS" ]; then
         echo "# Enable automatic referrals"
         echo "referrals yes"
    else
         echo "# Disable automatic referrals"
         echo "referrals no"
    fi
    echo ""

    echo "# For security reasons, the UIDs are limited to the range 1000-65499"
    echo "pam_min_uid 1000"
    echo ""

    if [ -n "$PAM_FILTER" ]; then
        echo "# PAM filter"
        echo "pam_filter $PAM_FILTER"
        echo ""
    fi

    if [ -n "$LDAP_GID" ] ; then
        echo "# Override GID returned by a LDAP lookup"
        echo "nss_override_attribute_value gidNumber $LDAP_GID"
        echo ""
    fi

    if [ -d "$NOHOME" ] ; then
        echo "# Override home directory returned by a LDAP lookup"
        echo "nss_override_attribute_value homeDirectory /home/nohome"
        echo ""
    fi

    echo "# Override login shell returned by a LDAP lookup"
    echo "nss_override_attribute_value loginShell /bin/bash"
    echo ""

    echo "# End of file"
    echo ""
    ) >> $LDAP_CONF_TMP

    syslog_debug_message "Exit create_ldap_conf_tmp()"
}

# Update the nsswitch.conf file.
# nss_ldap is used to perform all LDAP communications and translations for passwd, shadow and groupi & this can be performed by configuring /etc/nsswitch.conf
# It is pointing out the which order the authentication should be made, ie local files/ldap

update_nsswitch_conf_tmp() {
    syslog_debug_message "Enter update_nsswitch_conf_tmp()"
    # Only add ldap to group if group com-ldap exist
    if [ -z "$LDAP_GID" ] ; then
	ldap="ldap"
    fi

    cp -p $NSSWITCH_CONF $NSSWITCH_CONF_TMP
    sed -i    -e '/^group:/ s/[[:space:]]*ldap//g' \
    -e "/^group:/ s/$/ ${ldap}/" \
    -e '/^passwd:/ s/[[:space:]]*ldap//g' \
    -e '/^passwd:/ s/$/ ldap/' \
    $NSSWITCH_CONF_TMP

    # Add shadow: compat to the nsswitch.conf file to remove the shadow entries from ldap.
    grep -q -s ^shadow: $NSSWITCH_CONF_TMP  || sed -i '/^group:/ashadow: compat' $NSSWITCH_CONF_TMP
    syslog_debug_message "Exit update_nsswitch_conf_tmp()"
}

# Create the pam SSHD config file. User authentication is attempted in the order specified by the pam.d file of the respective service (e.g., SSH).
# Add so it is using the ldap.so files
#
# Some options used below and their meaning
# default - all not explicitly mentioned values
# ignore  - Ignore underlying account module regardless of whether the
#          control flag is required, optional, or sufficient
# new_authtok_reqd - New authentication token required. This is normally
#                    returned if the machine security policies require that
#                    the password should be changed beccause the password
#                    is NULL or it has aged
# success - Successful function return

create_sshd_tmp() {
    syslog_debug_message "Enter create_sshd_tmp()"
    (
    echo "$AUTO_MSG"
# Check if user is in the nologin file. If not, continue
    echo "auth      requisite                     pam_nologin.so"
# Check if user is a local user. "success=2" means: if success, skip next 2 rules
# If not success, do next rule (do ldap authentication).
    echo "auth      [default=ignore success=2]    pam_localuser.so"
    echo "auth      required     pam_env.so"
# Do LDAP authentication and then exit.
# if success then pam auth is successful and skip further auth processing
# if fail, exit and fail auth processing
    echo "auth      [success=done new_authtok_reqd=done ignore=ignore default=die]    pam_ldap.so"
    echo "auth      include      common-auth"
    echo "auth      required     pam_loginallow.so"
    echo ""
# Check if user is a local user. "success=1" means: if success, skip next 1 rule
# If not success, do next rule.
    echo "account   [default=ignore success=1]    pam_localuser.so"
    echo "account   [success=done new_authtok_reqd=done ignore=ignore default=die]    pam_ldap.so"
    echo "account   include      common-account"
    echo ""
    # Check if user is a local user. "success=2" means: if success, skip next 2 rules
    # If not success, do next rule.
    echo "password  [default=ignore success=2]    pam_localuser.so"
    echo "password  requisite    pam_pwcheck.so  nullok cracklib use_first_pass"
    echo "password  [success=done new_authtok_reqd=done ignore=ignore default=die]    pam_ldap.so"
    echo "password  include      common-password"
    echo ""
    echo "session   required     pam_loginuid.so"
    echo "session   include      common-session"
    echo "session   [default=1 success=ignore]    pam_localuser.so"
    echo "session   required     pam_mkhomedir.so"
    ) > $PAM_SSHD_CONF_TMP
    syslog_debug_message "Exit create_sshd_tmp()"
}

# Create the pam systemd-user config file.
#
# Some options used below and their meaning
# default - all not explicitly mentioned values
# ignore  - Ignore underlying account module regardless of whether the
#          control flag is required, optional, or sufficient
# new_authtok_reqd - New authentication token required. This is normally
#                    returned if the machine security policies require that
#                    the password should be changed beccause the password
#                    is NULL or it has aged
# success - Successful function return

create_systemd_user_tmp() {
    syslog_debug_message "Enter create_systemd_user_tmp()"
    (
    echo "$AUTO_MSG"
    echo "#%PAM-1.0"
    echo ""
    echo "# Used by systemd when launching systemd user instances."
    echo ""
# Check if user is a local user. "success=1" means: if success, skip next 1 rule
# If not success, do next rule.
    echo "account   [default=ignore success=1]    pam_localuser.so"
    echo "account   [success=done new_authtok_reqd=done ignore=ignore default=die]    pam_ldap.so"
    echo "account   include      common-account"
    echo ""
    echo "session   include      common-session"
    echo "auth      required     pam_deny.so"
    echo "password  required     pam_deny.so"
    ) > $PAM_SYSTEMD_USER_CONF_TMP
    syslog_debug_message "Exit create_systemd_user_tmp()"
}


# Helper function: Wait for a file to be copied from cluster to local node.
# Wait 2 sec between each try and max 20 sec (com ea wrapper times out after 30)
wait_for_files_to_sync() {
    syslog_debug_message "Enter wait_for_files_to_sync()"

    #To check if ldap.conf is synced.
    local ldapconfsynced=0

    #To check if nsswitch.conf is synced.
    local nsswitchconfsynced=0

    #To check if pam.d/sshd is synced
    local pamsshdsynced=0

    #To check if pam.d/systemd-user is synced
    local pamsystemdusersynced=0

    local x=1
    while [ $x -le 10 ]
    do
       compare_file $ldapconfsynced $CLUSTER_LDAP_CONF $LDAP_CONF
       ldapconfsynced=$?
       compare_file $nsswitchconfsynced $CLUSTER_NSSWITCH_CONF $NSSWITCH_CONF
       nsswitchconfsynced=$?
       compare_file $pamsshdsynced $CLUSTER_PAM_SSHD_CONF $PAM_SSHD_CONF
       pamsshdsynced=$?
       compare_file $pamsystemdusersynced $CLUSTER_PAM_SYSTEMD_USER_CONF $PAM_SYSTEMD_USER_CONF
       pamsystemdusersynced=$?

       if [ $pamsshdsynced -eq 1 ] && [ $ldapconfsynced -eq 1 ] ; then
          if [ $nsswitchconfsynced -eq 1 ] && [ $pamsystemdusersynced -eq 1 ]; then
              syslog_debug_message "All files have synced."
              syslog_debug_message "Exit wait_for_files_to_sync()"
              return 1
          fi
       fi

       sleep 1
       x=`expr $x + 1 `
    done
    if [ $x -gt 10 ]
    then
	syslog_error_message "Warning: Failed to sync within time limit of 10 sec."
        syslog_debug_message "Exit wait_for_files_to_sync()"
        return 0
    fi
}

#Compare remote and local files.
compare_file() {
    if [ $1 -eq 0 ]; then
       # To check if the remote cluster file exists. No meaning to compare if file not found.
       if ! [ -f $2 ]; then
           syslog_error_message "File $2 does not exist and can therefore not be synced."
           return 1
       fi

       if cmp -s "$2" "$3"; then
           syslog_debug_message "File $3 synced"
           return 1
       else
           return 0
       fi
    else
        return 1
    fi
}


# Set ldap value in the final temp config files and restart "Name Service Cache Daemon"
set_ldap_config() {
    syslog_debug_message "Enter set_ldap_config()"
    # Set ldap config
    create_ldap_conf_tmp
    update_nsswitch_conf_tmp
    create_sshd_tmp
    create_systemd_user_tmp

    #Create pam TLSD tmp file from pam SSHD tmp file
    if [ $isTlsdExists = true ] ; then
        cp -pf $PAM_SSHD_CONF_TMP  $PAM_TLSD_CONF_TMP
    fi

    #To check if ldap.conf is restored.
    local ldapconfrestored=0

    #To check if nsswitch.conf is restored.
    local nsswitchconfrestored=0

    #To check if pam.d/sshd is restored
    local pamsshdrestored=0

    #To check if pam.d/systemd-user is restored
    local pamsystemduserrestored=0

    #To check if pam.d/tlsd is restored
    local pamtlsdrestored=0

    local y=1
    while [ $y -le 3 ]
    do
      # Move temporary files to remote location
      restore_remotefile $ldapconfrestored $LDAP_CONF_TMP $CLUSTER_LDAP_CONF
      ldapconfrestored=$?
      restore_remotefile $nsswitchconfrestored $NSSWITCH_CONF_TMP $CLUSTER_NSSWITCH_CONF
      nsswitchconfrestored=$?
      restore_remotefile $pamsshdrestored $PAM_SSHD_CONF_TMP $CLUSTER_PAM_SSHD_CONF
      pamsshdrestored=$?
      restore_remotefile $pamsystemduserrestored $PAM_SYSTEMD_USER_CONF_TMP $CLUSTER_PAM_SYSTEMD_USER_CONF
      pamsystemduserrestored=$?
      if [ $isTlsdExists = true ] ; then
          restore_remotefile $pamtlsdrestored $PAM_TLSD_CONF_TMP $PAM_TLSD_CONF
          pamtlsdrestored=$?
      fi

      if [ $ldapconfrestored -eq 1 ] && [ $nsswitchconfrestored -eq 1 ]; then
         if [ $pamsshdrestored -eq 1 ] && [ $pamsystemduserrestored -eq 1 ]; then
             if [ $isTlsdExists = false ] || [ $pamtlsdrestored -eq 1 ] ; then
                 local nscd_user=`ps -ef | grep nscd | grep -v "grep" | awk '{print $1}'`
                 local nscd_group=`id -gn $nscd_user`
                 chgrp $nscd_group $CLUSTER_LDAP_CONF
                 chmod 640 $CLUSTER_LDAP_CONF
                 syslog_debug_message "$CLUSTER_LDAP_CONF file group changed to $nscd_group"
                 syslog_debug_message "All ldap config files are succesfully updated."
                 break;
             fi
         fi
      fi

      y=`expr $y + 1 `
    done

    if [ $y -gt 3 ]
      then
         syslog_error_message "Warning: Failed to update all ldap config files."
         syslog_debug_message "Exit set_ldap_config()"
         exit $ERROR
    fi

    rm $LDAP_CONF_TMP $NSSWITCH_CONF_TMP $PAM_SSHD_CONF_TMP $PAM_SYSTEMD_USER_CONF_TMP $PAM_TLSD_CONF_TMP

    # Wait for all files to be synced.
    wait_for_files_to_sync

    # Restart nscd if all files have synced.
    if [ $? -ne 0 ]; then
        # Restart "Name Service Cache Daemon"
        syslog_debug_message "restarting name service cache daemon"
        restart_nscd
    else
        syslog_error_message "ldap config files have not synced so nscd is not restarted"
    fi
    syslog_debug_message "Exit set_ldap_config()"
}


# restore or update(copy/move) remote file using default or generated ones, while
# doing this, remote file might result in "empty", so should act acordingly;
# refer to LDE Trouble Report and Support Case Writing Guideline (section 2.2)
restore_remotefile() {
    if [ $1 -eq 0 ]; then
        cp -p $2 ${3}.tmp
        mv ${3}.tmp $3
        if [ -s $2 ]; then
          if ! [ -s $3 ] ; then
             syslog_error_message "File $3 found as empty"
             return 0
          fi
        fi

        if cmp -s "$2" "$3"; then
           syslog_debug_message "File $3 restored successfully"
           return 1
        else
           syslog_error_message "File $3 could not be restored properly"
           return 0 #file found to be different after copy/move
        fi
    else
        return 1
    fi
}

# Restore the default config and restart "Name Service Cache Daemon".Restores all the default configuration files(i.e., syncd.conf,ldap.conf,ldaprc,nsswitch.conf,sshd) & restarts "Name Service Cache Daemon".
set_default_config() {
    syslog_debug_message "Enter set_default_config()"

    #To check if ldap.conf.default is restored.
    local ldapconfdefrestored=0

    #To check if nsswitch.conf.default is restored.
    local nsswitchconfdefrestored=0

    #To check if pam.d/sshd.default is restored
    local pamsshddefrestored=0

    #To check if pam.d/systemd-user.default is restored
    local pamsystemduserdefrestored=0

    #To check if pam.d/tlsd.default is restored
    local pamtlsddefrestored=0

    local z=1
    while [ $z -le 3 ]
    do
      # Set default config
      restore_remotefile $ldapconfdefrestored $LDAP_CONF_DEFAULT $CLUSTER_LDAP_CONF
      ldapconfdefrestored=$?
      restore_remotefile $nsswitchconfdefrestored $NSSWITCH_CONF_DEFAULT $CLUSTER_NSSWITCH_CONF
      nsswitchconfdefrestored=$?
      restore_remotefile $pamsshddefrestored $PAM_SSHD_CONF_DEFAULT $CLUSTER_PAM_SSHD_CONF
      pamsshddefrestored=$?
      restore_remotefile $pamsystemduserdefrestored $PAM_SYSTEMD_USER_CONF_DEFAULT $CLUSTER_PAM_SYSTEMD_USER_CONF
      pamsystemduserdefrestored=$?
      if [ $isTlsdExists = true ] ; then
          restore_remotefile $pamtlsddefrestored $PAM_TLSD_CONF_DEFAULT $PAM_TLSD_CONF
          pamtlsddefrestored=$?
      fi

      if [ $ldapconfdefrestored -eq 1 ] && [ $nsswitchconfdefrestored -eq 1 ]; then
         if [ $pamsshddefrestored -eq 1 ] && [ $pamsystemduserdefrestored -eq 1 ] ; then
             if [ $isTlsdExists = false ] || [ $pamtlsddefrestored -eq 1 ] ; then
                 syslog_debug_message "All default config files are succesfully restored."
                 break;
             fi
         fi
      fi

      z=`expr $z + 1 `
    done

    if [ $z -gt 3 ]
    then
       syslog_error_message "Warning: Failed to restore all default config files."
       syslog_debug_message "Exit set_default_config()"
       exit $ERROR
    fi

    # Wait for all files to be synced.
    wait_for_files_to_sync

    # Restore syncd and restart nscd if all files are synced.
    if [ $? -ne 0 ]; then

        # Restore and restart syncd
        restore_syncd

        # Restart "Name Service Cache Daemon"
        syslog_debug_message "restarting name service cache daemon"
        restart_nscd
    else
        syslog_error_message "ldap config files have not synced so syncd cannot be restored and restarted."
    fi
    syslog_debug_message "Exit set_default_config()"
}


# Read settings from file and set the values in the final files.
apply_config() {
    syslog_debug_message "Enter apply_config()"
    if [ "$AUTH_TYPE" = "ldap" ]; then
        set_ldap_config
    elif [ "$AUTH_TYPE" = "default" ]; then
        set_default_config
    else
        syslog_error_message "Unknown AUTH_TYPE: '$AUTH_TYPE'"
        exit $ERROR
    fi
    syslog_debug_message "Exit apply_config()"
}


# For testing
# Check if prepare was given, then print args to a file and exit.
check_if_prepare_set() {
    syslog_debug_message "Enter check_if_prepare_set()"
    if [ $PREPARE -eq 1 ]; then
        if [ -n $COMEA_ROOT_DIR ]; then
            echo "$AUTH_TYPE $ALL_REAL_ARGS" >> $COMEA_ROOT_DIR/test_log/authentication-method-set_prepare.log
	    PREPARE=0
        fi
	syslog_debug_message "Exit check_if_prepare_set() (exit 0)"
        exit 0
    fi
    syslog_debug_message "Exit check_if_prepare_set()"
}

# Add the script's syncd entries to the syncd.conf file and restart syncd
# syncd.conf file controls authentication, access, logging, available modules.
# 4th argument i.e., update_remote when true updates the remote syncd.conf & doesnt update when false.
# 5th argument i.e., control_only when true 
set_syncd_config() {
    syslog_debug_message "Enter set_syncd_config()"
    # Restore file from file-entries created by this script.
    restore_syncd

    # Add files to be synced.
    ADD_NEWLINE=0
    SYNCD_CONF_TMP="`mktemp`"
    add_syncd_entry "LDAP Configuration" $LDAP_CONF $CLUSTER_LDAP_CONF "false" "false" "" $SYNCD_CONF_TMP
    add_syncd_entry "NS Switch Configuration" $NSSWITCH_CONF $CLUSTER_NSSWITCH_CONF "false" "false" "" $SYNCD_CONF_TMP
    add_syncd_entry "PAM SSHD Configuration" $PAM_SSHD_CONF $CLUSTER_PAM_SSHD_CONF "false" "false" "" $SYNCD_CONF_TMP
    add_syncd_entry "PAM systemd-user Configuration" $PAM_SYSTEMD_USER_CONF $CLUSTER_PAM_SYSTEMD_USER_CONF "false" "false" "" $SYNCD_CONF_TMP

    # Stop syncd
    stop_syncd
    RC=$?
    cat $SYNCD_CONF_TMP >> $SYNCD_CONF
    # Start syncd (only if stop_syncd did not return INTERNAL_SYNCD_ALREADY_STOPPED)
    if [ $RC -ne $INTERNAL_SYNCD_ALREADY_STOPPED ]; then
       start_syncd
    fi
    rm $SYNCD_CONF_TMP

    syslog_debug_message "Exit set_syncd_config() (rc=0)"
    return 0
}


# Add a syncd entry to /etc/syncd.conf file
add_syncd_entry() {
    syslog_debug_message "Enter add_syncd_entry()"
    if [ "$4" != "true" ] && [ "$4" != "false" ]; then
       syslog_error_message "Argument $4 need to be either true or false"
       exit $ERROR
    fi

    if [ "$5" != "true" ] && [ "$5" != "false" ]; then
       syslog_error_message "Argument $5 need to be either true or false"
       exit $ERROR
    fi

    if [ ! -x $6 ]; then
       syslog_error_message "File $6 does not exist, or isn't executable"
       exit $ERROR
    fi

    if [ -f $7 ]; then
       TMP_FILE=$7
    else
       TMP_FILE=$SYNCD_CONF
    fi

    # Don't add newline for first append.
    if [ $ADD_NEWLINE -eq 1 ]; then
       /bin/echo -e "\n"                          >> $TMP_FILE
    else
       /bin/echo -e -n "\n"                       >> $TMP_FILE
       ADD_NEWLINE=1
    fi
    /bin/echo "file {"                            >> $TMP_FILE
    /bin/echo -e "\tdescription    = \""$1"\","   >> $TMP_FILE
    /bin/echo -e "\tlocal          = \""$2"\","   >> $TMP_FILE
    /bin/echo -e "\tremote         = \""$3"\","   >> $TMP_FILE
    /bin/echo -e "\tupdate_remote  = $4,"         >> $TMP_FILE
    /bin/echo -e "\tcontrol_only   = $5,"         >> $TMP_FILE
    /bin/echo -e "\tlocal_update_cmd = \""$6"\""  >> $TMP_FILE
    /bin/echo -n "}"                              >> $TMP_FILE
       
    syslog_debug_message "Exit add_syncd_entry() (rc=0)"
    return 0
}

# Add entries in syncd.conf and remove duplicate entries
# File is copied to /tmp to avoid growing syncd.conf if the uid running this script's has no write permission in /tmp.
restore_syncd() {
    syslog_debug_message "Enter restore_syncd()"
    SED_FILTER_EXPR="sed -e 's/\//\\\ \//g' | sed -e 's/ //g' | sed -e 's/\./\\\./g'"

    # Add escape character before '/' and '.' to make the path fit into the sed expression.
    SED_LOCAL_LDAP_CONF=`echo $LDAP_CONF | eval $SED_FILTER_EXPR`
    SED_REMOTE_CLUSTER_LDAP_CONF=`echo $CLUSTER_LDAP_CONF | eval $SED_FILTER_EXPR`
    SED_LOCAL_NSSWITCH_CONF=`echo $NSSWITCH_CONF | eval $SED_FILTER_EXPR`
    SED_REMOTE_NSSWITCH_CONF=`echo $CLUSTER_NSSWITCH_CONF | eval $SED_FILTER_EXPR`
    SED_LOCAL_PAM_SSHD_CONF=`echo $PAM_SSHD_CONF | eval $SED_FILTER_EXPR`
    SED_REMOTE_PAM_SSHD_CONF=`echo $CLUSTER_PAM_SSHD_CONF | eval $SED_FILTER_EXPR`
    SED_LOCAL_PAM_SYSTEMD_USER_CONF=`echo $PAM_SYSTEMD_USER_CONF | eval $SED_FILTER_EXPR`
    SED_REMOTE_PAM_SYSTEMD_USER_CONF=`echo $CLUSTER_PAM_SYSTEMD_USER_CONF | eval $SED_FILTER_EXPR`


    SYNCD_CONF_TMP="`mktemp`"
    # Read 7 lines after the 'file' keyword and remove the file-clause based on
    # contents of local and remote file name. 
    # Remove identical consecutive newlines in file.
    # Remove trailing newline in file.
    cat $SYNCD_CONF | \
    eval "sed -e '{/^file/ {N;N;N;N;N;N;N; /file[ \t\n]*{.*local[ \t]*=[ \t]*\"$SED_LOCAL_LDAP_CONF.*remote[ \t]*=[ \t]*\"$SED_REMOTE_CLUSTER_LDAP_CONF.*}/d}}'" | \
    eval "sed -e '{/^file/ {N;N;N;N;N;N;N; /file[ \t\n]*{.*local[ \t]*=[ \t]*\"$SED_LOCAL_NSSWITCH_CONF.*remote[ \t]*=[ \t]*\"$SED_REMOTE_NSSWITCH_CONF.*}/d}}'" | \
    eval "sed -e '{/^file/ {N;N;N;N;N;N;N; /file[ \t\n]*{.*local[ \t]*=[ \t]*\"$SED_LOCAL_PAM_SSHD_CONF.*remote[ \t]*=[ \t]*\"$SED_REMOTE_PAM_SSHD_CONF.*}/d}}'" | \
    eval "sed -e '{/^file/ {N;N;N;N;N;N;N; /file[ \t\n]*{.*local[ \t]*=[ \t]*\"$SED_LOCAL_PAM_SYSTEMD_USER_CONF.*remote[ \t]*=[ \t]*\"$SED_REMOTE_PAM_SYSTEMD_USER_CONF.*}/d}}'" | \
    sed -e '$!N; /^\(.*\)\n\1$/!P; D' | \
    sed -e '${/^$/d}' > $SYNCD_CONF_TMP

    # Stop syncd
    stop_syncd
    RC=$?
    cp -p $SYNCD_CONF_TMP $SYNCD_CONF
    # Start syncd (only if stop_syncd did not return INTERNAL_SYNCD_ALREADY_STOPPED)
    if [ $RC -ne $INTERNAL_SYNCD_ALREADY_STOPPED ]; then
       start_syncd
    fi
    rm $SYNCD_CONF_TMP
    syslog_debug_message "Exit restore_syncd()"
}

# Stop the syncd daemon to update /etc/syncd.conf
# Returns 0 on successful stop of syncd, otherwise !=0
stop_syncd() {
   syslog_debug_message "Stopping synchronization daemon"

   # Don't stop syncd if already stopped, instead return INTERNAL_SYNCD_ALREADY_STOPPED.
   service lde-syncd status > /dev/null 2>&1
   RC=$?
   if [ $RC -eq 3 ]; then
      syslog_error_message "Error: Stop of syncd failed, syncd was already stopped."      
      return $INTERNAL_SYNCD_ALREADY_STOPPED
   fi 
   
   service lde-syncd stop > /dev/null 2>&1
   RC=$?
   if [ $RC -ne 0 ]; then
     syslog_error_message "Error: Stop of syncd failed, syncd stop returned $RC"
     return $RC
   fi

   service lde-syncd status > /dev/null 2>&1
   RC=$?
   if [ $RC -ne 3 ]; then
     syslog_error_message "Error: Stop of syncd failed, syncd status returned $RC"
     if [ $RC -ne 0 ]; then
       return $RC
     else
       # syncd status should not have returned 0, return INTERNAL_ERROR to indicate this failure.
       return $INTERNAL_ERROR
     fi
   fi 

   return 0
}

# Start the syncd daemon to use the updated /etc/syncd.conf
# Returns 0 on successful start of syncd, otherwise !=0
start_syncd() {
   syslog_debug_message "Starting synchronization daemon"

   service lde-syncd status > /dev/null 2>&1
   RC=$?
   if [ $RC -eq 3 ]; then
      service lde-syncd start > /dev/null 2>&1
      RC=$?
      if [ $RC -ne 0 ]; then
        syslog_error_message "Error: Start of syncd failed, syncd start returned $RC"
        return $RC
      fi 
   fi
   
   service lde-syncd status > /dev/null 2>&1
   RC=$?
   if [ $RC -ne 0 ]; then
     syslog_error_message "Error: Start of syncd failed, syncd status returned $RC"
     return $RC
   fi 
   
   return 0
}


# Parse options known
parse_opts() {
    syslog_debug_message "Enter parse_opts()"
    # Prepare getopt
    GETOPT="`which getopt 2>/dev/null`"
    readonly GETOPT="${GETOPT:=/usr/bin/getopt}"
    if [ ! -x "${GETOPT}" ]; then
        syslog_error_message "authentication-method-set failed, missing ${GETOPT} or is not executable."
        exit $ERROR
    fi
    readonly PROGNAME="${0##*/}"

    lopts='prepare,nodeType:,base-dn:,bind-dn:,bind-password:,password-file:,login-attribute:,tls-ca-certificate:,tls-ca-cert-directory:,tls-client-certificate:,tls-client-key:,uri:,useTls,tls-mode:,cipherFilter:,useReferrals'
    args=`${GETOPT} -n ${PROGNAME} -l ${lopts} "" "$@"`
    RC=$?
    if [ $RC -ne 0 ]; then
	   syslog_error_message "Error: getopt failed, rc=$RC"
	   return $ERROR
    fi

    eval set -- "$args"
    if [ -n "$OLD_LOTC_FOUND" ]; then
     while true; do
        case "$1" in
        --prepare)
            PREPARE=1
            break
            ;;
        --nodeType)
            NODE_TYPE="$(echo $2 | tr -d "'")"
            shift
            ;;
        --)
            # End, if parameter list finished
            break
            ;;
        --useTls)
            # No way to detect if it is a single-option or value-option, so this needs to be added for all no-value-options
            ARG_LIST=$ARG_LIST" $1"
            ;;
        *)
            # Save the remaining args in ARG_LIST
            # Option with argument, copy valuename and value
            # Remove ' and add =
            ARG_LIST=$ARG_LIST" $1=$(echo $2 | tr -d "'")"
            shift
            ;;
        esac
            shift
    done
   else
    while true; do
        case "$1" in
            --prepare)
                PREPARE=1
                break
                ;;
            --nodeType)
                NODE_TYPE="`echo $2 | tr -d "'"`"
                shift
                ;;
            --base-dn)
	        baseDnUsed=true
                BASE_DN="`echo $2 | tr -d "'"`"
                shift
                ;;
            --bind-dn)
                BIND_DN="`echo $2 | tr -d "'"`"
                shift
                ;;
            --bind-password)
                syslog_error_message "Option --bind-password is obsolete."
                exit $ERROR
                ;;
            --password-file)
                PASSWORD_FILE="`echo $2 | tr -d "'"`"
                shift
                ;;
            --login-attribute)
                LOGIN_ATTR="`echo $2 | tr -d "'"`"
                shift
                ;;
            --tls-ca-certificate)
                TLS_CA_CERT="`echo $2 | tr -d "'"`"
                shift
                ;;
            --tls-ca-cert-directory)
                TLS_CA_CERT_DIR="`echo $2 | tr -d "'"`"
                shift
                ;;
            --tls-client-certificate)
                TLS_CLIENT_CERT="`echo $2 | tr -d "'"`"
                shift
                ;;
            --tls-client-key)
                TLS_CLIENT_KEY="`echo $2 | tr -d "'"`"
                shift
                ;;
            --useTls)
                ACTIVATE_TLS=true
                ;;
            --cipherFilter)
                TLS_CIPHERS="`echo $2 | tr -d "'"`"
                shift
                ;;
            --uri)
                NEW_URI="`echo $2 | tr -d "'"`"
                if [ -z $URIS ]; then
                    URIS=$NEW_URI
                else
                    URIS="$URIS $NEW_URI"
                fi
                shift
                ;;
           --tls-mode)
               TLS_MODE="$(echo $2 | tr -d "'")"
               shift
               ;;
           --useReferrals)
               ACTIVATE_REFERRALS=true
               ;;
            --)
                # End of parameter list
                break
                ;;
            *)
                syslog_error_message "Unknown parameter: '$1'"
                exit $ERROR
                ;;
            esac
                shift
    done
    if [ $ACTIVATE_TLS ] && [ -z $TLS_CIPHERS ]
    then
         TLS_CIPHERS = $DEFAULT_TLS_CIPHERS
    fi
    syslog_debug_message "Exit parse_opts()"
fi
}


# Main 
# Check if old LOTC script should be used.
# Parse command line options
# Check if prepare was specified, then exit.
# Save old default files
# If default is specified, then apply default settings.
# Create Pam-filters from nodetypes
# Create new temp files
# Create syncd.conf
# Apply new config 
main() {
    syslog_debug_message "Command: $*"
    syslog_debug_message "Enter main()"
    # shift away "authentication"
    shift

    #shift away "ldap" or "default"
    AUTH_TYPE="$1"
    shift

    # For testing
    # Save the script arguments for debug AND local FT test case
    ALL_REAL_ARGS="$@"

    # Check if old LOTC, then use it 
    check_if_old_LOTC_script_exists "$@"
    RC=$?
    if [ $RC -ne 0 ]; then
       syslog_debug_message "Checking if old LOTC script exists, rc=$RC"
       return $RC
    fi

    # No old LOTC, do normal process
    # Parse the COM EA options
    parse_opts "$@"
    RC=$?
    if [ $RC -ne 0 ]; then
       syslog_debug_message "Parsing options, rc=$RC"
       return $RC
    fi

    check_if_prepare_set

    # Always check that the default files are saved
    save_default_files

    if [ "$AUTH_TYPE" = "--apply" ] || [ "$AUTH_TYPE" = "--boot" ]; then
		syslog_error_message "Option $AUTH_TYPE is obsolete."
		exit $ERROR
    fi
    if [ "$AUTH_TYPE" = "default" ]; then
        set_syncd_config
		apply_config
        syslog_debug_message "Exit main() (exit 0)"
        exit 0
    fi
    if [ "$AUTH_TYPE" != "ldap" ]; then
        syslog_error_message "authentication-method-set failed, missing argument <authentication-type>"
        exit $ERROR
    fi

    PAM_FILTER=`format_pam_filter "$NODE_TYPE"`
    check_ldap_args
    set_syncd_config
    apply_config
    syslog_debug_message "Exit main()"
}

syslog_debug_message "ETC_DIR=$ETC_DIR"
syslog_debug_message "CLUSTER_ETC_DIR=$CLUSTER_ETC_DIR"
syslog_debug_message "ACTIVATE_TLS=$ACTIVATE_TLS"

main "$@"

# Exit with the status of the last command
exit
